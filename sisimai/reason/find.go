// Copyright (C) 2024 azumakuniyuki and sisimai development team, All rights reserved.
// This software is distributed under The BSD 2-Clause License.
package reason

//  _ __ ___  __ _ ___  ___  _ __  
// | '__/ _ \/ _` / __|/ _ \| '_ \ 
// | | |  __/ (_| \__ \ (_) | | | |
// |_|  \___|\__,_|___/\___/|_| |_|
import "strings"
import "sisimai/sis"
import "sisimai/smtp/status"

// Find() detects and returns the bounce reason
func Find(fo *sis.Fact) string {
	// @param    *sis.Fact fo    Struct to be detected the reason
	// @return   string          Bounce reason name or an empty string

	// Return the reason text already decided except the reason matched with the name defined in
	// GetRetried (generated by Retry() function)
	if fo.Reason != "" && GetRetried[fo.Reason]   == false { return fo.Reason   }
	if strings.HasPrefix(fo.DeliveryStatus, "2.") == true  { return "delivered" }

	reasontext := ""
	issuedcode := strings.ToLower(fo.DiagnosticCode)
	codeformat := fo.DiagnosticType

	if codeformat == "SMTP" || codeformat == "" {
		// Diagnostic-Code: SMTP; ... or empty value
		for _, e := range ClassOrder[0] {
			// Check the values of Diagnostic-Code: and Status: fields using truth() function of
			// each child class in Sisimai::Reason
			if ProbesInto[e](fo) == false { continue }
			reasontext = strings.ToLower(e); break
		}
	}

	if reasontext == "" || reasontext == "undefined" {
		// The bounce reason is not detected yet at the code block above
		reasontext = anotherone(fo) // Try to find a reason name using anotherone()
		if reasontext == "undefined"                  { reasontext = ""          }
		if reasontext == "" && fo.Action == "delayed" { reasontext = "expired"   }
		if reasontext != ""                           { return reasontext        }

		// Try to match with message patterns in Sisimai::Reason::Vacation
		if IncludedIn["Vacation"](issuedcode)         { reasontext = "vacation"  }
		if reasontext == "" && issuedcode != ""       { reasontext = "onhold"    }
		if reasontext == ""                           { reasontext = "undefined" }
	}
	return reasontext
}

// anotherone() detects the other bounce reason, fall back method for Find()
func anotherone(fo *sis.Fact) string {
	// @param    *sis.Fact fo    Struct to be detected the reason
	// @return   string          Bounce reason name or an empty string
	if IsExplicit(fo.Reason) == true { return fo.Reason }

	issuedcode := strings.ToLower(fo.DiagnosticCode)
	reasontext := status.Name(fo.DeliveryStatus)
	trytomatch := false
	forsubject := ""

	for trytomatch == false {
		// Set true when the reasontext is listed in GetRetried or fo.DiagnosticType is "SMTP"
		if reasontext == ""            { trytomatch = true; break }
		if GetRetried[reasontext]      { trytomatch = true; break }
		if fo.DiagnosticType == "SMTP" { trytomatch = true; break }
		break
	}

	for trytomatch == true {
		// The value of the reason is not decided yet by the fo.DeliveryStatus
		for _, e := range ClassOrder[1] {
			// Trying to match with other patterns in sisimai/reason/*.go
			if IncludedIn[e](issuedcode) == false { continue }
			reasontext = strings.ToLower(e); break
		}
		if reasontext != "" { break }

		// Check the value of "Status:" field (fo.DeliveryStatus)
		if len(fo.DeliveryStatus) > 3 { forsubject = fo.DeliveryStatus[0:3] }
		if forsubject == "5.6" || forsubject == "4.6" {
			// X.6.0   Other or undefined media error
			reasontext = "contenterror"

		} else if forsubject == "5.7" || forsubject == "4.7" {
			// X.7.0   Other or undefined security status
			reasontext = "securityerror"

		} else { 
			// - Diagnostic-Code: X-UNIX; ..., X-Postfix, or other X-*
			// - 50X Syntax Error?
			if strings.HasPrefix(fo.DiagnosticType, "X-UNIX") { reasontext = "mailererror"; break }
			if ProbesInto["SyntaxError"](fo) == true          { reasontext = "syntaxerror"; break }
		}
		if reasontext != "" { break }

		// Check the value of "Action:" field (fo.Action)
		if strings.HasPrefix(fo.Action, "delayed") || strings.HasPrefix(fo.Action, "expired") {
			// Action: delayed, expired
			reasontext = "expired"

		} else {
			// Check the value of the SMTP command (fo.SMTPCommand)
			if fo.SMTPCommand == "EHLO" || fo.SMTPCommand == "HELO" {
				// Rejected an SMTP connection or after sending EHLO, HELO
				reasontext = "blocked"
			}
		}
		break
	}
	return reasontext
}

